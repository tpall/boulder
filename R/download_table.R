

#' Recode downloaded variables
#' @param var original variable, atomic vector.
#' @param lookup named list with original variable and replacement.
recode_vars <- function(var, lookup) {
  do.call(dplyr::recode, c(list(var), lookup))
}

#' Download TAI data table
#'
#' @param variable a table Name from list_variables(), a character string.
#' @param vars table of available variables, a data_frame generated by
#' list_variables() function. Defaults to NULL, in which case internal
#' table is used.
#' @param lang Language, a character string. "et" -- Estonian, "en" -- English.
#'
#' @examples
#' # Download data for table 'RK01'
#' rk01 <- dl_tai_table("RK01", lang = "en")
#' rk01
#'
#' @importFrom magrittr "%>%"
#' @export
dl_tai_table <- function(variable, vars = NULL, lang = c("et", "en")) {

  lang <- match.arg(lang)

  if (is.null(vars)) {
    vars <- list_variables(lang = lang)
  }

  if (!"tai_tables" %in% class(vars)) {
    stop("Please supply vars table generated by list_variables() function.")
  }

  # Download and process metadata
  md <- dplyr::filter(vars, Name == variable) %>%
    dplyr::mutate(resp = purrr::pmap(list(Database, Node, Name), get_tables, lang = lang),
                  metadata = purrr::map(resp, ~ .x$content$variables))

  valuetexts <- md[["metadata"]][[1]] %>%
    dplyr::select(text, values, valueTexts) %>%
    dplyr::as_data_frame() %>%
    tidyr::unnest() %>%
    dplyr::group_by(text) %>%
    split(.$text) %>%
    purrr::map(~ tidyr::spread(.x, key = "text", value = "values"))

  metadata <- md %>%
    dplyr::mutate(metadata = purrr::map(metadata, ~ dplyr::filter(.x, purrr::map_lgl(elimination, isTRUE)))) %>%
    "[["("metadata") %>%
    unlist(recursive = FALSE) %>%
    purrr::map(unlist)

  # Create json structure
  query <- list(code = metadata$code,
                selection = list(filter = "item",
                                 values = metadata$values))

  json <- list(query = list(query),
               response = list(format = "json")) %>%
    jsonlite::toJSON(pretty = TRUE, auto_unbox = TRUE)

  # Construct query URL
  dbi <- md$Database
  node <- md$Node
  tab <- stringr::str_c(md$Name, ".px")
  path <- file.path("/PXWeb2015/api/v1/", lang, dbi, node, tab)
  url <- httr::modify_url("http://pxweb.tai.ee", path = path)

  # Run query
  resp <- httr::POST(url = url, body = json)
  jsonresponse <- httr::content(resp, "text") %>% jsonlite::fromJSON()
  columns <- jsonresponse$columns
  data <- jsonresponse$data
  data <- dplyr::as_data_frame(data) %>% tidyr::unnest(values)
  data <- do.call(rbind, data$key) %>%
    dplyr::as_data_frame() %>%
    dplyr::bind_cols(dplyr::data_frame(data$values))
  colnames(data) <- columns$text

  # Recode variables
  toberecoded <- intersect(colnames(data), names(valuetexts))
  vars <- data %>%
    dplyr::select(toberecoded) %>%
    rlang::as_list(.)

  repl <- valuetexts %>%
    purrr::map(~ split(.x[[1]], .x[[2]])) %>%
    purrr::map(unlist) %>%
    .[names(vars)]

  recoded_vars <- dplyr::data_frame(vars, repl) %>%
    dplyr::mutate(recoded = purrr::map2(vars, repl, recode_vars)) %>%
    "[["("recoded") %>%
    dplyr::bind_cols()

  # Merge recoded variables with values
  value <- setdiff(colnames(data), names(valuetexts))
  data %>%
    dplyr::select(value) %>%
    dplyr::bind_cols(recoded_vars, .)
}

